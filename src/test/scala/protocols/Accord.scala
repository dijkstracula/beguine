package protocols

import beguine.runtime.{Arbitrary, Protocol, RandomArbitrary}
import beguine.sorts.Enum
import beguine.{Maps, sorts}
import org.scalatest.BeforeAndAfter
import org.scalatest.funspec.AnyFunSpec

import scala.collection.mutable
import scala.util.Random

class Accord extends AnyFunSpec with BeforeAndAfter {

  /* Autogenerated at 24/05/2024 at 11:06:21 at commit 99d7506 adjust logical assignments to new Map implementation */
  class PorterIsolate(a: Arbitrary) extends Protocol(a) {
    val index = beguine.sorts.Number(0, Int.MaxValue)
    val node_id = beguine.sorts.Number(0, 3)

    class node_id__iter__t {
      var is_end: Boolean = false
      var val_ident: Int = 0

      private def canEqual(other: Any): Boolean = other.isInstanceOf[node_id__iter__t]

      override def equals(other: Any): Boolean = other match {
        case that: node_id__iter__t =>
          that.canEqual(this) &&
            is_end == that.is_end &&
            val_ident == that.val_ident
        case _ => false
      }

      override def hashCode(): Int = {
        val state = Seq(is_end, val_ident)
        state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b)
      }

      override def toString = {
        val state = Seq(is_end, val_ident)
        "node_id.iter.t(" + state.foldLeft("")((a, b) => a + ", " + b) + ")"
      }
    }

    def <(X: node_id__iter__t, Y: node_id__iter__t): Boolean = {
      !X.is_end && Y.is_end || !X.is_end && !Y.is_end && X.val_ident < Y.val_ident
    }

    object node_id__iter__t extends sorts.Record[node_id__iter__t] {
      override def arbitrary(a: Arbitrary) = {
        val ret = new node_id__iter__t
        ret.is_end = a.bool()
        ret.val_ident = a.numeric(node_id)
        ret
      }
    }


    class node_it__t {
      var is_end: Boolean = false
      var val_ident: Int = 0

      private def canEqual(other: Any): Boolean = other.isInstanceOf[node_it__t]

      override def equals(other: Any): Boolean = other match {
        case that: node_it__t =>
          that.canEqual(this) &&
            is_end == that.is_end &&
            val_ident == that.val_ident
        case _ => false
      }

      override def hashCode(): Int = {
        val state = Seq(is_end, val_ident)
        state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b)
      }
    }

    //class node_it__t__ivysort extends sorts.Record[node_it__t] {}

    class nset {
      var repr: mutable.ArraySeq[Int] = mutable.ArraySeq.empty
    }

    //class nset__ivysort extends sorts.Record[nset] {}

    val nset__index = beguine.sorts.Number(0, Int.MaxValue)
    val nset__api__impl__arridx = beguine.sorts.Number(0, Int.MaxValue)

    class tcp__endpoint {
      var addr: Long = 0L
      var port: Long = 0L

      private def canEqual(other: Any): Boolean = other.isInstanceOf[tcp__endpoint]

      override def equals(other: Any) = {
        other match {
          case that: tcp__endpoint => that.canEqual(this) && addr == that.addr && port == that.port
          case _ => false
        }
      }

      override def hashCode(): Int = {
        val state = Seq(addr, port)
        state.map(_.hashCode()).foldLeft(0)((a, b) => 31 * a + b)
      }

      override def toString: String = {
        val state = Seq(addr, port)
        "tcp.endpoint(" + state.foldLeft("")((a, b) => a + ", " + b) + ")"
      }
    }

    object tcp__endpoint extends sorts.Record[tcp__endpoint] {
      override def arbitrary(a: Arbitrary) = {
        val ret = new tcp__endpoint
        ret.addr = a.bitvec(sorts.BitVec(32))
        ret.port = a.bitvec(sorts.BitVec(16))
        ret
      }

    }

    val nat = beguine.sorts.Number(0, Int.MaxValue)
    val walltime = beguine.sorts.Number(0, Int.MaxValue)
    val sequence = beguine.sorts.Number(0, Int.MaxValue)

    class timestamp {
      var real: Int = 0
      var seqid: Int = 0
    }

    class timestamp__ivysort extends sorts.Record[timestamp] {
      override def arbitrary(a: Arbitrary): timestamp = {
        val ret = new timestamp()
        ret.real = a.numeric(walltime)
        ret.seqid = a.numeric(sequence)
        ret
      }
    }

    object txn_kind_t extends Enumeration {
      type txn_kind_t = Value
      val read_kind, write_kind = Value
    }

    import txn_kind_t._

    class query_t {
      var kind: txn_kind_t = read_kind
      var k: Int = 0
      var v: mutable.ArraySeq[Int] = mutable.ArraySeq.empty
    }

    class query_t__ivysort extends sorts.Record[query_t] {
      override def arbitrary(a: Arbitrary): query_t = {
        val ret = new query_t()
        ret.kind = a.enumeration(Enum(txn_kind_t))
        ret.k = a.uninterpreted
        ret.v = mutable.ArraySeq.empty //TODO
        ret
      }
    }

    class txn_t extends sorts.Record[txn_t] {
      var origin: Int = 0
      var id: Int = 0
      var ts: timestamp = new timestamp()
      var queries: mutable.ArraySeq[query_t] = mutable.ArraySeq.empty

      override def arbitrary(a: Arbitrary): txn_t = {
        val ret = new txn_t()
        ret.origin = a.numeric(node_id)
        ret.id = a.uninterpreted
        ret.ts = a.record(new timestamp__ivysort())
        ret.queries = mutable.ArraySeq.empty //TODO
        ret
      }
    }

    class txn_t_ivysort extends sorts.Record[txn_t] {
      override def arbitrary(a: Arbitrary): txn_t = {
        val ret = new txn_t()
        ret.origin = a.numeric(node_id)
        ret.id = a.uninterpreted
        ret.ts = a.record(new timestamp__ivysort())
        ret.queries = mutable.ArraySeq.empty //TODO
        ret
      }
    }

    object msg_t_kind extends Enumeration {
      type msg_t_kind = Value
      val preaccept_kind, preaccept_resp_kind, accept_kind, accept_resp_kind, commit_kind = Value
    }

    import msg_t_kind._

    class msg_t {
      var kind: msg_t_kind = preaccept_kind
      var src: Int = 0
      var txn: txn_t = new txn_t()
      var ok: Boolean = false
      var first_proposed_at: timestamp = new timestamp()
      var witnessed_at: timestamp = new timestamp()
      var deps: mutable.ArraySeq[txn_t] = mutable.ArraySeq.empty
      var execute_at: timestamp = new timestamp()
    }

    object msg_t extends sorts.Record[msg_t] {
      override def arbitrary(a: Arbitrary): msg_t = {
        val ret = new msg_t()
        ret.kind = a.enumeration(Enum(msg_t_kind))
        ret.src = a.numeric(node_id)
        ret.txn = a.record(new txn_t_ivysort())
        ret.ok = a.bool()
        ret
      }
    }

    var node_id__max: Int = 3
    var protocol__preaccepted: Maps.Map2[Int, txn_t, Boolean] = new Maps.Map2[Int, txn_t, Boolean](node_id, new txn_t_ivysort())
    var protocol__committed: Maps.Map3[Int, txn_t, timestamp, Boolean] = new Maps.Map3[Int, txn_t, timestamp, Boolean](node_id, new txn_t_ivysort(), new timestamp__ivysort())
    var net__queue: Maps.Map2[tcp__endpoint, tcp__endpoint, mutable.ArraySeq[msg_t]] = new Maps.Map2[tcp__endpoint, tcp__endpoint, mutable.ArraySeq[msg_t]](tcp__endpoint, tcp__endpoint)
    var net__len: Maps.Map2[tcp__endpoint, tcp__endpoint, Int] = new Maps.Map2[tcp__endpoint, tcp__endpoint, Int](tcp__endpoint, tcp__endpoint)
    var coordinator__next_txn_id: Maps.Map1[Int, Int] = new Maps.Map1[Int, Int](node_id)
    var coordinator__current_txn: Maps.Map1[Int, mutable.ArraySeq[txn_t]] = new Maps.Map1[Int, mutable.ArraySeq[txn_t]](node_id)
    //var coordinator__deps__internal__s: Maps.Map1[Int, HashSet < txn_t >] = new Maps.Map1[Int, HashSet < txn_t >](node_id)
    var coordinator__slowpath_accepts: Maps.Map1[Int, nset] = new Maps.Map1[Int, nset](node_id)
    var coordinator__fastpath_accepts: Maps.Map1[Int, nset] = new Maps.Map1[Int, nset](node_id)
    var coordinator__sb: Maps.Map1[Int, mutable.ArraySeq[txn_t]] = new Maps.Map1[Int, mutable.ArraySeq[txn_t]](node_id)
    var coordinator__clock__curr_time: Maps.Map1[Int, Int] = new Maps.Map1[Int, Int](node_id)
    var coordinator__clock__latest_observed: Maps.Map1[Int, timestamp] = new Maps.Map1[Int, timestamp](node_id)
    var coordinator__clock__prev_issued: Maps.Map1[Int, timestamp] = new Maps.Map1[Int, timestamp](node_id)
    var coordinator__sock__id: Maps.Map1[Int, tcp__endpoint] = new Maps.Map1[Int, tcp__endpoint](node_id)
    var coordinator__fd__my_electorate: Maps.Map1[Int, nset] = new Maps.Map1[Int, nset](node_id)
    var coordinator__fd__electorate_size: Maps.Map1[Int, Int] = new Maps.Map1[Int, Int](node_id)
    var coordinator__client_in_flight: Maps.Map1[Int, Boolean] = new Maps.Map1[Int, Boolean](node_id)
    var x: Int = 0
    exported[Int, Unit]("ext:coordinator.clock.tick", ext__coordinator__clock__tick, node_id)
    exported[Int, tcp__endpoint, msg_t, Unit]("ext:coordinator.sock.recv", ext__coordinator__sock__recv, node_id, tcp__endpoint, msg_t)

    protocol__preaccepted.initWithDefault(() => false)
    protocol__committed.initWithDefault(() => false)
    coordinator__client_in_flight.initWithDefault(() => false)

    node_id.inhabitants.get.foreach(prm__V0 => {
      coordinator__clock__curr_time(prm__V0) = 1
      coordinator__clock__latest_observed(prm__V0) = new timestamp()
      coordinator__clock__latest_observed(prm__V0).real = 0
      coordinator__clock__latest_observed(prm__V0).seqid = 0
      coordinator__clock__prev_issued(prm__V0) = coordinator__clock__latest_observed(prm__V0)

      coordinator__fd__electorate_size(prm__V0) = 5
      var loc__i: Int = 0
      loc__i = 1
      var loc__curr: Int = 0
      loc__curr = prm__V0
      while (loc__i <= coordinator__fd__electorate_size(prm__V0)) {
        coordinator__fd__my_electorate(prm__V0) = new nset()
        coordinator__fd__my_electorate(prm__V0) = nset__add(coordinator__fd__my_electorate(prm__V0), loc__curr)
        if (loc__curr == node_id__max) {
          loc__curr = 0
        } else {
          loc__curr = node_id__next(loc__curr)
        }
        loc__i = nat__next(loc__i)
      }
      coordinator__fd__net_init_electorate(prm__V0, coordinator__fd__my_electorate(prm__V0))
    })

    node_id.inhabitants.get.foreach(self => {
      coordinator__next_txn_id(self) = 0
      coordinator__fastpath_accepts(self) = nset__emptyset()
      coordinator__slowpath_accepts(self) = nset__emptyset()
      coordinator__current_txn(self) = option_of_txn_t___empty()
    })

    def node_id__iter__value(X: node_id__iter__t): Int = {
      X.val_ident
    }

    def node_it__value(X: node_it__t): Int = {
      X.val_ident
    }

    def nset__disjoint(X: nset, Y: nset): Boolean = {
      false /* TODO */
    }

    def nset__member(y: Int, X: nset): Boolean = {
      false /* TODO */
      //Range(0, 3).forall(Z => 0 <= Z && Z < nset__api__impl__arr__end(nset__api__impl__repr(X)) && nset__api__impl__arr__value(nset__api__impl__repr(X), Z) == y)
    }

    def nat__next(X: Int): Int = {
      if (X + 1 < 0)
        0
      else X + 1
    }

    def ts_eq(LHS: timestamp, RHS: timestamp): Boolean = {
      LHS.real == RHS.real && LHS.seqid == RHS.seqid
    }

    def ts_lt(LHS: timestamp, RHS: timestamp): Boolean = {
      LHS.real < RHS.real || LHS.real == RHS.real && LHS.seqid < RHS.seqid
    }

    def ts_gt(LHS: timestamp, RHS: timestamp): Boolean = {
      LHS.real > RHS.real || LHS.real == RHS.real && LHS.seqid > RHS.seqid
    }

    def ts_le(LHS: timestamp, RHS: timestamp): Boolean = {
      ts_eq(LHS, RHS) || ts_lt(LHS, RHS)
    }

    def vector_of_query_t___begin(A: mutable.ArraySeq[query_t]): Int = {
      0
    }

    def interfering_queries(ks1: mutable.ArraySeq[query_t], ks2: mutable.ArraySeq[query_t]): Boolean = {
      false
      //vector_of_query_t___begin(ks1) <= I1 && I1 < vector_of_query_t___end(ks1) && vector_of_query_t___begin(ks2) <= I2 && I2 < vector_of_query_t___end(ks2) && vector_of_query_t___value(ks1, I1).kind == txn_kind_t.write_kind || vector_of_query_t___value(ks2, I2).kind == txn_kind_t.write_kind && vector_of_query_t___value(ks1, I1).k == vector_of_query_t___value(ks2, I2).k
    }

    def conflicts_with(t1: txn_t, t2: txn_t): Boolean = {
      !(t1.origin == t2.origin && t1.id == t2.id) && interfering_queries(t1.queries, t2.queries)
    }

    def vector_of_txn_t___begin(A: mutable.ArraySeq[txn_t]): Int = {
      0
    }

    def option_of_timestamp___is_empty(X: mutable.ArraySeq[timestamp]): Boolean = {
      option_of_timestamp___end(X) == 0
    }

    def option_of_timestamp___contents(X: mutable.ArraySeq[timestamp]): timestamp = {
      option_of_timestamp___value(X, 0)
    }

    def nset__cnt(x: Int): Int = {
      if (x <= 0) {
        1
      } else {
        if (
          nset__cnt(if (x - 1 > 3) 3 else if (x - 1 < 0) 0 else x - 1) + 1 < 0
        ) 0 else nset__cnt(if (x - 1 > 3) 3 else if (x - 1 < 0) 0 else x - 1) + 1
      }
    }

    def nset__majorities_intersect__impl__cardUpTo(s: nset, b: Int): Int = {
      if (b <= 0) {
        if (nset__member(b, s)) 1 else 0
      } else {
        if (nset__majorities_intersect__impl__cardUpTo(s, if (b - 1 < 0) 0 else b - 1) + (if (nset__member(b, s)) 1 else 0) < 0)
          0
        else nset__majorities_intersect__impl__cardUpTo(s, if (b - 1 < 0) 0 else b - 1) + (if (nset__member(b, s)) 1 else 0)
      }
    }

    def nset__card(S: nset): Int = {
      nset__majorities_intersect__impl__cardUpTo(S, node_id__max)
    }

    def nset__majorities_intersect__impl__cardInterUpTo(s1: nset, s2: nset, b: Int): Int = {
      if (b <= 0) {
        if (nset__member(b, s1) && nset__member(b, s2)) 1 else 0
      } else {
        if (nset__majorities_intersect__impl__cardInterUpTo(s1, s2, if (b - 1 < 0) 0 else b - 1) + (if (nset__member(b, s1) && nset__member(b, s2)) 1 else 0) < 0)
          0
        else nset__majorities_intersect__impl__cardInterUpTo(s1, s2, if (b - 1 < 0) 0 else b - 1) + (if (nset__member(b, s1) && nset__member(b, s2)) 1 else 0)
      }
    }

    def nset__cardInter(S: nset, T: nset): Int = {
      nset__majorities_intersect__impl__cardInterUpTo(S, T, node_id__max)
    }

    def nset__majority(X: nset, Y: nset): Boolean = {
      (2 * nset__cardInter(X, Y)) > nset__card(Y)
    }

    def nset__unanimity(X: nset, Y: nset): Boolean = {
      nset__cardInter(X, Y) == nset__card(Y)
    }

    def nset__api__impl__arr__value(a: mutable.ArraySeq[Int], i: Int): Int = {
      a(i)
    }

    def nset__api__impl__arr__end(a: mutable.ArraySeq[Int]): Int = {
      a.size
    }

    def option_of_value___value(a: mutable.ArraySeq[Int], i: Int): Int = {
      a(i)
    }

    def option_of_value___end(a: mutable.ArraySeq[Int]): Int = {
      a.size
    }

    def vector_of_query_t___value(a: mutable.ArraySeq[query_t], i: Int): query_t = {
      a(i)
    }

    def vector_of_query_t___end(a: mutable.ArraySeq[query_t]): Int = {
      a.size
    }

    def vector_of_txn_t___value(a: mutable.ArraySeq[txn_t], i: Int): txn_t = {
      a(i)
    }

    def vector_of_txn_t___end(a: mutable.ArraySeq[txn_t]): Int = {
      a.size
    }

    def option_of_timestamp___value(a: mutable.ArraySeq[timestamp], i: Int): timestamp = {
      a(i)
    }

    def option_of_timestamp___end(a: mutable.ArraySeq[timestamp]): Int = {
      a.size
    }

    def net__msgvec__value(a: mutable.ArraySeq[msg_t], i: Int): msg_t = {
      a(i)
    }

    def net__msgvec__end(a: mutable.ArraySeq[msg_t]): Int = {
      a.size
    }

    def net__msgvec__segment(a: mutable.ArraySeq[msg_t], lo: Int, hi: Int): mutable.ArraySeq[msg_t] = {
      a.slice(lo, hi)
    }

    def option_of_txn_t___value(a: mutable.ArraySeq[txn_t], i: Int): txn_t = {
      a(i)
    }

    def option_of_txn_t___end(a: mutable.ArraySeq[txn_t]): Int = {
      a.size
    }

    def index__next(x: Int): Int = {
      var y: Int = 0
      y = if (x + 1 < 0) 0 else x + 1
      y
    }

    def node_id__next(x: Int): Int = {
      var y: Int = 0
      y = if (x + 1 > 3) 3 else if (x + 1 < 0) 0 else x + 1
      y
    }

    def ext__node_id__next(x: Int): Int = {
      var y: Int = 0
      y = if (x + 1 > 3) 3 else if (x + 1 < 0) 0 else x + 1
      y
    }

    def ext__node_id__is_max(x: Int): Boolean = {
      var r: Boolean = false
      r = x == node_id__max
      r
    }

    def ext__node_id__iter__create(x: Int): node_id__iter__t = {
      var y: node_id__iter__t = new node_id__iter__t()
      y.is_end = false
      y.val_ident = x
      y
    }

    def ext__node_id__iter__begin(): node_id__iter__t = {
      var y: node_id__iter__t = new node_id__iter__t()
      y.is_end = false
      y.val_ident = 0
      y
    }

    def ext__node_id__iter__end(): node_id__iter__t = {
      var y: node_id__iter__t = new node_id__iter__t()
      y.is_end = true
      y.val_ident = 0
      y
    }

    def ext__node_id__iter__next(x0: node_id__iter__t): node_id__iter__t = {
      var x = x0
      var loc__0: Boolean = false
      loc__0 = ext__node_id__is_max(x.val_ident)
      if (loc__0) {
        x = ext__node_id__iter__end
      } else {
        var loc__0: Int = 0
        loc__0 = ext__node_id__next(x.val_ident)
        x = ext__node_id__iter__create(loc__0)
      }
      x
    }

    def ext__node_it__create(x: Int): node_it__t = {
      var y: node_it__t = new node_it__t()
      y.is_end = false
      y.val_ident = x
      y
    }

    def node_it__begin(): node_it__t = {
      var y: node_it__t = new node_it__t()
      y.is_end = false
      y.val_ident = 0
      y
    }

    def node_it__end(): node_it__t = {
      var y: node_it__t = new node_it__t()
      y.is_end = true
      y.val_ident = 0
      y
    }

    def ext__node_it__end(): node_it__t = {
      var y: node_it__t = new node_it__t()
      y.is_end = true
      y.val_ident = 0
      y
    }

    def node_it__next(x0: node_it__t): node_it__t = {
      var x = x0
      var loc__0: Boolean = false
      loc__0 = ext__node_id__is_max(x.val_ident)
      if (loc__0) {
        x = ext__node_it__end
      } else {
        var loc__0: Int = 0
        loc__0 = ext__node_id__next(x.val_ident)
        x = ext__node_it__create(loc__0)
      }
      x
    }

    def nset__emptyset(): nset = {
      var s: nset = new nset()
      s.repr = ext__nset__api__impl__arr__create(0, 0)
      s
    }

    def nset__fullset(): nset = {
      var s: nset = new nset()
      s.repr = ext__nset__api__impl__arr__create(0, 0)
      var loc__0: node_id__iter__t = new node_id__iter__t()
      loc__0 = ext__node_id__iter__begin
      var loc__it: node_id__iter__t = new node_id__iter__t()
      loc__it = loc__0
      loc__0 = ext__node_id__iter__end
      var loc__en: node_id__iter__t = new node_id__iter__t()
      loc__en = loc__0
      while (loc__it.val_ident < loc__en.val_ident) {
        s.repr = ext__nset__api__impl__arr__append(s.repr, node_id__iter__value(loc__it))
        loc__it = ext__node_id__iter__next(loc__it)
      }
      s
    }

    def nset__add(s: nset, e: Int): nset = {
      if (!(nset__member(e, s))) {
        var loc__0: Int = 0
        loc__0 = ext__nset__api__impl__arridx__next(nset__api__impl__arr__end(s.repr))
        s.repr = ext__nset__api__impl__arr__resize(s.repr, loc__0, e)
      }
      s
    }

    def ext__nset__api__impl__arridx__next(x: Int): Int = {
      var y: Int = 0
      y = if (x + 1 < 0) 0 else x + 1
      y
    }

    def ext__nset__api__impl__arr__create(s: Int, y: Int): mutable.ArraySeq[Int] = {
      var a: mutable.ArraySeq[Int] = mutable.ArraySeq.empty
      a = mutable.ArraySeq.fill(s)(y)
      a
    }

    def ext__nset__api__impl__arr__resize(a: mutable.ArraySeq[Int], s: Int, v: Int): mutable.ArraySeq[Int] = {
      /* TODO */
      a
    }

    def ext__nset__api__impl__arr__append(a: mutable.ArraySeq[Int], v: Int): mutable.ArraySeq[Int] = {
      a :+ v
    }

    def walltime__next(x: Int): Int = {
      var y: Int = 0
      y = if (x + 1 < 0) 0 else x + 1
      y
    }

    def sequence__next(x: Int): Int = {
      var y: Int = 0
      y = if (x + 1 < 0) 0 else x + 1
      y
    }

    def option_of_value___create(s: Int, y: Int): mutable.ArraySeq[Int] = {
      var a: mutable.ArraySeq[Int] = mutable.ArraySeq.empty
      a = mutable.ArraySeq.fill(s)(y)
      a
    }

    def option_of_value___just(inp: Int): mutable.ArraySeq[Int] = {
      var out: mutable.ArraySeq[Int] = mutable.ArraySeq.empty
      out = option_of_value___create(1, inp)
      out
    }

    def vector_of_query_t___append(a: mutable.ArraySeq[query_t], v: query_t): mutable.ArraySeq[query_t] = {
      a :+ v
    }

    def vector_of_txn_t___append(a: mutable.ArraySeq[txn_t], v: txn_t): mutable.ArraySeq[txn_t] = {
      a :+ v
    }

    def filter_timestamps_lt(txns: mutable.ArraySeq[txn_t], ts: timestamp): mutable.ArraySeq[txn_t] = {
      var ret: mutable.ArraySeq[txn_t] = mutable.ArraySeq.empty
      var loc__it: Int = 0
      loc__it = vector_of_txn_t___begin(txns)
      var loc__e: Int = 0
      loc__e = vector_of_txn_t___end(txns)
      while (!(loc__it == loc__e)) {
        var loc__cur: txn_t = new txn_t()
        loc__cur = vector_of_txn_t___value(txns, loc__it)
        if (ts_lt(loc__cur.ts, ts)) {
          ret = vector_of_txn_t___append(ret, loc__cur)
        }
        loc__it = index__next(loc__it)
      }
      ret
    }

    def option_of_timestamp___empty(): mutable.ArraySeq[timestamp] = {
      var a: mutable.ArraySeq[timestamp] = mutable.ArraySeq.empty
      a
    }

    def option_of_timestamp___create(s: Int, y: timestamp): mutable.ArraySeq[timestamp] = {
      var a: mutable.ArraySeq[timestamp] = mutable.ArraySeq.empty
      a = mutable.ArraySeq.fill(s)(y)
      a
    }

    def option_of_timestamp___just(inp: timestamp): mutable.ArraySeq[timestamp] = {
      var out: mutable.ArraySeq[timestamp] = mutable.ArraySeq.empty
      out = option_of_timestamp___create(1, inp)
      out
    }

    def max_timestamp(txns: mutable.ArraySeq[txn_t]): timestamp = {
      var ret: timestamp = new timestamp()
      var loc__opt_ret: mutable.ArraySeq[timestamp] = mutable.ArraySeq.empty
      loc__opt_ret = option_of_timestamp___empty
      var loc__it: Int = 0
      loc__it = vector_of_txn_t___begin(txns)
      var loc__e: Int = 0
      loc__e = vector_of_txn_t___end(txns)
      while (!(loc__it == loc__e)) {
        var loc__cur: txn_t = new txn_t()
        loc__cur = vector_of_txn_t___value(txns, loc__it)
        if (option_of_timestamp___is_empty(loc__opt_ret) || ts_lt(option_of_timestamp___contents(loc__opt_ret), loc__cur.ts)) {
          loc__opt_ret = option_of_timestamp___just(loc__cur.ts)
        }
        loc__it = index__next(loc__it)
      }
      if (option_of_timestamp___is_empty(loc__opt_ret)) {
        ret.real = 0
        ret.seqid = 0
      } else {
        ret = option_of_timestamp___contents(loc__opt_ret)
      }
      ret
    }

    def dependencies(t: txn_t, sb: mutable.ArraySeq[txn_t]): mutable.ArraySeq[txn_t] = {
      var deps: mutable.ArraySeq[txn_t] = mutable.ArraySeq.empty
      var loc__it: Int = 0
      loc__it = vector_of_txn_t___begin(sb)
      var loc__e: Int = 0
      loc__e = vector_of_txn_t___end(sb)
      while (!(loc__it == loc__e)) {
        var loc__gamma: txn_t = new txn_t()
        loc__gamma = vector_of_txn_t___value(sb, loc__it)
        if (interfering_queries(t.queries, loc__gamma.queries)) {
          deps = vector_of_txn_t___append(deps, loc__gamma)
          loc__it = index__next(loc__it)
        }
      }
      deps
    }

    def ext__protocol__seqid_is_zero(msg: msg_t): Unit = {
      assumeThat(msg.first_proposed_at.seqid == 0)
    }

    def protocol__handle_requested(self: Int, msg: msg_t): Unit = {
      debug("protocol.handle_requested")
      assertThat("abstract_protocol.ivy", 73, msg.kind == msg_t_kind.preaccept_kind)
      assertThat("abstract_protocol.ivy", 74, msg.first_proposed_at == msg.txn.ts)
    }

    def protocol__handle_preaccepted(self: Int, msg: msg_t, resp: msg_t): Unit = {
      debug("protocol.handle_preaccepted")
      assertThat("abstract_protocol.ivy", 81, msg.kind == msg_t_kind.preaccept_kind, "TODO")
      assertThat("abstract_protocol.ivy", 82, resp.kind == msg_t_kind.preaccept_resp_kind, "TODO")
      var loc__tao: txn_t = new txn_t()
      loc__tao = msg.txn
      ext__protocol__seqid_is_zero(msg)
      assertThat("abstract_protocol.ivy", 100, msg.first_proposed_at == resp.first_proposed_at, "TODO")
      assertThat("abstract_protocol.ivy", 101, ts_le(resp.first_proposed_at, resp.witnessed_at), "TODO")
      //assertThat("abstract_protocol.ivy", 111, protocol__preaccepted.iterator.forall((self, Gamma) => protocol__preaccepted(self, Gamma) && conflicts_with(Gamma, loc__tao) implies !(Gamma.ts == loc__tao.ts))))
      //assertThat("abstract_protocol.ivy", 117, protocol__preaccepted.iterator.forall(Gamma => conflicts_with.iterator.forall(Gamma => protocol__preaccepted(P, Gamma) && protocol__preaccepted(R, loc__tao) && conflicts_with(Gamma, loc__tao) implies !(Gamma.ts == loc__tao.ts))))
      protocol__preaccepted((self, resp.txn)) = true
    }

    def protocol__handle_accepted(self: Int, msg: msg_t): Unit = {
      assertThat("abstract_protocol.ivy", 125, msg.kind == msg_t_kind.accept_kind, "TODO")
      debug("protocol.handle_acepted")

    }

    def protocol__handle_committed(self: Int, msg: msg_t): Unit = {
      assertThat("abstract_protocol.ivy", 132, msg.kind == msg_t_kind.commit_kind)
      debug("protocol.handle_committed")
      var loc__tao: txn_t = new txn_t()
      loc__tao = msg.txn
      //assertThat("abstract_protocol.ivy", 147, protocol__committed(P, loc__tao, At) implies At == loc__tao.ts)
      //assertThat("abstract_protocol.ivy", 155, protocol__committed(P, Gamma, GAt) && conflicts_with(Gamma, loc__tao) implies !(GAt == msg.execute_at))
      protocol__committed((self, loc__tao, msg.execute_at)) = true

    }

    def net__msgvec__append(a: mutable.ArraySeq[msg_t], v: msg_t): mutable.ArraySeq[msg_t] = {
      a :+ v
    }

    def option_of_txn_t___empty(): mutable.ArraySeq[txn_t] = {
      var a: mutable.ArraySeq[txn_t] = mutable.ArraySeq.empty
      a
    }

    def option_of_txn_t___create(s: Int, y: txn_t): mutable.ArraySeq[txn_t] = {
      var a: mutable.ArraySeq[txn_t] = mutable.ArraySeq.empty
      a = mutable.ArraySeq.fill(s)(y)
      a
    }

    def option_of_txn_t___just(inp: txn_t): mutable.ArraySeq[txn_t] = {
      var out: mutable.ArraySeq[txn_t] = mutable.ArraySeq.empty
      out = option_of_txn_t___create(1, inp)
      out
    }

    def coordinator__deps__insert(prm__V0: Int, nkey: txn_t): Unit = {
      //coordinator__deps__internal__s(prm__V0) :+ nkey
    }

    def coordinator__deps__internal__less(prm__V0: Int, x: txn_t, y: txn_t): Boolean = {
      var res: Boolean = false
      res = ts_le(x.ts, y.ts)
      res
    }

    def coordinator__clock__tick(prm__V0: Int): Unit = {
      coordinator__clock__curr_time(prm__V0) = walltime__next(coordinator__clock__curr_time(prm__V0))

    }

    def ext__coordinator__clock__tick(prm__V0: Int): Unit = {
      coordinator__clock__curr_time(prm__V0) = walltime__next(coordinator__clock__curr_time(prm__V0))

    }

    def coordinator__clock__now(prm__V0: Int): timestamp = {
      var ret: timestamp = new timestamp()
      coordinator__clock__tick(prm__V0)
      if (coordinator__clock__latest_observed(prm__V0).real >= coordinator__clock__curr_time(prm__V0)) {
        ret.real = coordinator__clock__latest_observed(prm__V0).real
        ret.seqid = sequence__next(coordinator__clock__latest_observed(prm__V0).seqid)
      } else {
        ret.real = coordinator__clock__curr_time(prm__V0)
        ret.seqid = 0
      }
      coordinator__clock__prev_issued(prm__V0) = coordinator__clock__latest_observed(prm__V0)
      coordinator__clock__latest_observed(prm__V0) = ret
      ret
    }

    def coordinator__clock__merge(prm__V0: Int, remote_ts: timestamp): Unit = {
      if (ts_lt(coordinator__clock__latest_observed(prm__V0), remote_ts)) {
        coordinator__clock__prev_issued(prm__V0) = coordinator__clock__latest_observed(prm__V0)
        coordinator__clock__latest_observed(prm__V0) = remote_ts
      }

    }

    def coordinator__sock__send(prm__V0: Int, dst: tcp__endpoint, msg: msg_t): Unit = {
      imp__coordinator__sock__send(prm__V0, dst, msg)
      var loc__thing: mutable.ArraySeq[msg_t] = mutable.ArraySeq.empty
      loc__thing = net__queue(coordinator__sock__id(prm__V0), dst)
      net__queue((coordinator__sock__id(prm__V0), dst)) = net__msgvec__append(loc__thing, msg)
      var loc__tmp2: mutable.ArraySeq[msg_t] = mutable.ArraySeq.empty
      loc__tmp2 = net__queue(coordinator__sock__id(prm__V0), dst)
      net__len((coordinator__sock__id(prm__V0), dst)) = net__msgvec__end(loc__tmp2)


    }

    def ext__coordinator__sock__recv(prm__V0: Int, src: tcp__endpoint, msg: msg_t): Unit = {
      assumeThat(net__len(src, coordinator__sock__id(prm__V0)) > 0)
      var loc__thing: mutable.ArraySeq[msg_t] = mutable.ArraySeq.empty
      loc__thing = net__queue(src, coordinator__sock__id(prm__V0))
      assumeThat(msg == net__msgvec__value(loc__thing, 0))
      coordinator__net_recv(prm__V0, msg)
      if (msg.kind == msg_t_kind.preaccept_kind) {
        coordinator__preaccept_handle(prm__V0, msg)
      } else {
        if (msg.kind == msg_t_kind.preaccept_resp_kind) {
          coordinator__preaccept_reply_handle(prm__V0, msg)
        } else {
          if (msg.kind == msg_t_kind.accept_kind) {
            coordinator__accept_handle(prm__V0, msg)
          } else {
            if (msg.kind == msg_t_kind.accept_resp_kind) {
              coordinator__accept_reply_handle(prm__V0, msg)
            } else {
              if (msg.kind == msg_t_kind.commit_kind) {
                coordinator__commit_handle(prm__V0, msg)
              } else {
                assertThat("protocol.ivy", 247, false, "false")
              }
            }
          }
        }
      }
      loc__thing = net__queue(src, coordinator__sock__id(prm__V0))
      net__queue((src, coordinator__sock__id(prm__V0))) = net__msgvec__segment(loc__thing, 1, net__msgvec__end(loc__thing))
      var loc__thing2: mutable.ArraySeq[msg_t] = mutable.ArraySeq.empty
      loc__thing2 = net__queue(src, coordinator__sock__id(prm__V0))
      net__len((src, coordinator__sock__id(prm__V0))) = net__msgvec__end(loc__thing2)

    }

    def coordinator__fd__net_init_electorate(prm__V0: Int, e: nset): Unit = {
      imp__coordinator__fd__net_init_electorate(prm__V0, e)

    }

    def ext__coordinator__fd__is_down(prm__V0: Int, other: Int): Unit = {
      debug("is_down")

    }

    def coordinator__net_send(self: Int, msg: msg_t, dst: Int): Unit = {
      imp__coordinator__net_send(self, msg, dst)

    }

    def coordinator__net_recv(self: Int, msg: msg_t): Unit = {
      imp__coordinator__net_recv(self, msg)

    }

    def ext__coordinator__client_request(self: Int, k: Int, v: Int): Unit = {
      if (self == 0 && !(coordinator__client_in_flight(self))) {
        coordinator__client_in_flight(self) = true
        var loc__0: timestamp = new timestamp()
        loc__0 = coordinator__clock__now(self)
        var loc__now: timestamp = new timestamp()
        loc__now = loc__0
        var loc__qs: mutable.ArraySeq[query_t] = mutable.ArraySeq.empty
        var loc__q: query_t = new query_t()
        loc__q.kind = txn_kind_t.write_kind
        loc__q.k = 0
        loc__q.v = option_of_value___just(v)
        loc__qs = vector_of_query_t___append(loc__qs, loc__q)
        var loc__txn: txn_t = new txn_t()
        loc__txn.origin = self
        loc__txn.id = coordinator__next_txn_id(self)
        loc__txn.ts = loc__now
        loc__txn.queries = loc__qs
        coordinator__next_txn_id(self) = if (coordinator__next_txn_id(self) + 1 < 0) 0 else coordinator__next_txn_id(self) + 1
        var loc__msg: msg_t = new msg_t()
        loc__msg.kind = msg_t_kind.preaccept_kind
        loc__msg.src = self
        loc__msg.txn = loc__txn
        loc__msg.first_proposed_at = loc__now
        coordinator__electorate_multicast(self, loc__msg)
        protocol__handle_requested(self, loc__msg)
      }

    }

    def coordinator__preaccept_handle(self: Int, msg: msg_t): Unit = {
      assertThat("protocol.ivy", 124, msg.kind == msg_t_kind.preaccept_kind)
      var loc__deps: mutable.ArraySeq[txn_t] = mutable.ArraySeq.empty
      loc__deps = dependencies(msg.txn, coordinator__sb(self))
      var loc__mc: timestamp = new timestamp()
      var loc__proposed_exec_ts: timestamp = new timestamp()
      loc__mc = max_timestamp(loc__deps)
      if (ts_gt(msg.first_proposed_at, loc__mc)) {
        loc__proposed_exec_ts = msg.first_proposed_at
      } else {
        loc__proposed_exec_ts.real = loc__mc.real
        loc__proposed_exec_ts.seqid = sequence__next(loc__mc.seqid)
      }
      var loc__resp: msg_t = new msg_t()
      loc__resp.kind = msg_t_kind.preaccept_resp_kind
      loc__resp.ok = true
      loc__resp.src = self
      loc__resp.txn = msg.txn
      loc__resp.txn.ts = loc__proposed_exec_ts
      loc__resp.deps = filter_timestamps_lt(loc__deps, msg.first_proposed_at)
      loc__resp.first_proposed_at = msg.first_proposed_at
      loc__resp.witnessed_at = loc__proposed_exec_ts
      coordinator__unicast(self, loc__resp, msg.src)
      coordinator__current_txn(self) = option_of_txn_t___just(msg.txn)
      protocol__handle_preaccepted(self, msg, loc__resp)

    }

    def coordinator__preaccept_reply_handle(self: Int, msg: msg_t): Unit = {
      assertThat("protocol.ivy", 157, msg.kind == msg_t_kind.preaccept_resp_kind)
      if (msg.ok) {
        var loc__it: Int = 0
        loc__it = vector_of_txn_t___begin(msg.deps)
        var loc__loc__end: Int = 0
        loc__loc__end = vector_of_txn_t___end(msg.deps)
        while (loc__it < loc__loc__end) {
          var loc__d: txn_t = new txn_t()
          loc__d = vector_of_txn_t___value(msg.deps, loc__it)
          coordinator__deps__insert(self, loc__d)
          loc__it = index__next(loc__it)
        }
        if (msg.witnessed_at == msg.first_proposed_at) {
          coordinator__fastpath_accepts(self) = nset__add(coordinator__fastpath_accepts(self), msg.src)
        } else {
          coordinator__slowpath_accepts(self) = nset__add(coordinator__slowpath_accepts(self), msg.src)
        }
        if (nset__unanimity(
          coordinator__fastpath_accepts(self), coordinator__fd__my_electorate(self)
        )) {
          var loc__resp: msg_t = new msg_t()
          loc__resp.kind = msg_t_kind.commit_kind
          loc__resp.src = self
          loc__resp.txn = msg.txn
          loc__resp.execute_at = msg.first_proposed_at
          coordinator__replica_multicast(self, loc__resp)
        } else {
          var loc__0: nset = new nset()
          loc__0 = nset__fullset
          if (nset__majority(coordinator__slowpath_accepts(self), loc__0)) {
            assertThat("protocol.ivy", 184, false)
          }
        }
      }

    }

    def coordinator__accept_reply_handle(self: Int, msg: msg_t): Unit = {
      assertThat("protocol.ivy", 195, msg.kind == msg_t_kind.accept_resp_kind)

    }

    def coordinator__accept_handle(self: Int, msg: msg_t): Unit = {
      assertThat("protocol.ivy", 200, msg.kind == msg_t_kind.accept_kind)
      coordinator__clock__merge(self, msg.execute_at)
      var loc__deps: mutable.ArraySeq[txn_t] = mutable.ArraySeq.empty
      loc__deps = dependencies(msg.txn, coordinator__sb(self))
      loc__deps = filter_timestamps_lt(loc__deps, msg.execute_at)
      var loc__resp: msg_t = new msg_t()
      loc__resp.kind = msg_t_kind.accept_resp_kind
      loc__resp.ok = true
      loc__resp.src = self
      loc__resp.txn = msg.txn
      loc__resp.deps = loc__deps
      coordinator__unicast(self, loc__resp, msg.src)
      protocol__handle_accepted(self, msg)

    }

    def coordinator__commit_handle(self: Int, msg: msg_t): Unit = {
      assertThat("protocol.ivy", 225, msg.kind == msg_t_kind.commit_kind)
      protocol__handle_committed(self, msg)

    }

    def coordinator__unicast(self: Int, outgoing: msg_t, dst_id: Int): Unit = {
      coordinator__net_send(self, outgoing, dst_id)
      coordinator__sock__send(self, coordinator__sock__id(dst_id), outgoing)

    }

    def coordinator__replica_multicast(self: Int, outgoing: msg_t): Unit = {
      coordinator__broadcast(self, outgoing)

    }

    def coordinator__electorate_multicast(self: Int, outgoing: msg_t): Unit = {
      var loc__0: node_it__t = new node_it__t()
      loc__0 = node_it__begin
      var loc__it: node_it__t = new node_it__t()
      loc__it = loc__0
      loc__0 = node_it__end
      var loc__e: node_it__t = new node_it__t()
      loc__e = loc__0
      while (!(loc__it == loc__e)) {
        if (nset__member(node_it__value(loc__it), coordinator__fd__my_electorate(self))) {
          coordinator__unicast(self, outgoing, node_it__value(loc__it))
        }
        loc__it = node_it__next(loc__it)
      }

    }

    def coordinator__broadcast(self: Int, outgoing: msg_t): Unit = {
      var loc__0: node_it__t = new node_it__t()
      loc__0 = node_it__begin
      var loc__it: node_it__t = new node_it__t()
      loc__it = loc__0
      loc__0 = node_it__end
      var loc__e: node_it__t = new node_it__t()
      loc__e = loc__0
      while (!(loc__it == loc__e)) {
        coordinator__unicast(self, outgoing, node_it__value(loc__it))
        loc__it = node_it__next(loc__it)
      }

    }

    def imp__coordinator__net_recv(self: Int, msg: msg_t): Unit = {
      debug("coordinator.net_recv", self, msg)
    }

    def imp__coordinator__fd__net_init_electorate(prm__V0: Int, e: nset): Unit = {
      debug("coordinator.fd.net_init_electorate", prm__V0, e)
    }

    def imp__coordinator__net_send(self: Int, msg: msg_t, dst: Int): Unit = {
      debug("coordinator.net_send", self, msg, dst)
    }

    def imp__coordinator__sock__send(prm__V0: Int, dst: tcp__endpoint, msg: msg_t): Unit = {
      debug("coordinator.sock.send", prm__V0, dst, msg)
    }
  }

  describe("The Accord wrapper") {
    implicit val r: Random = new Random(42)
    val a: RandomArbitrary = new RandomArbitrary()

    it("can be constructed and initialized") {
      val iso = new PorterIsolate(a)
    }

    it("can issue a client request") {
      val iso = new PorterIsolate(a)
      iso.ext__coordinator__client_request(0, 42, 99)
      assert(iso.coordinator__client_in_flight(0) == true)
      assert(true)
    }
  }
}
