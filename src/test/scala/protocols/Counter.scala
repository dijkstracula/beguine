package protocols

import beguine.ConjectureFailure
import beguine.runtime.{Arbitrary, Protocol, RandomArbitrary}
import org.scalatest.BeforeAndAfter
import org.scalatest.funspec.AnyFunSpec
import protocols.NonNegCounter

import scala.util.Random

class Counter extends AnyFunSpec with BeforeAndAfter {
  implicit val r: Random = new Random(42)

  /* Autogenerated at 20/05/2024 at 13:24:04 at commit e209a25 wip */
  class PorterIsolate(a: Arbitrary) extends Protocol(a) {
    val int = beguine.sorts.Number(Int.MinValue, Int.MaxValue)


    var mutator__count: Int = 0

    exported[Unit]("ext:mutator.inc", ext__mutator__inc);
    exported[Unit]("ext:mutator.dec", ext__mutator__dec);

    conjectured("mutator.nonnegativity", "007_counter.ivy", 35, () => mutator__count >= 0);

    mutator__count = 1;


    def ext__mutator__inc(): Unit = {
      mutator__count = mutator__count + 1;
      mutator__show(mutator__count);
      assertThat("007_counter.ivy", 31, true, "true");

    }

    def ext__mutator__dec(): Unit = {
      mutator__count = mutator__count - 1;
      mutator__show(mutator__count);

    }

    def mutator__show(c: Int): Unit = {
      imp__mutator__show(c);

    }

    def imp__mutator__show(c: Int): Unit = {
      debug("mutator.show", c)
    }
  }

  describe("The non-negative counter test") {
    val p = new NonNegCounter(new RandomArbitrary())
    it("should eventually fail") {
      assertThrows[ConjectureFailure] {
        for (_ <- 1 to 10) {
          p() match {
            case Left(e) => throw e
            case Right(()) => ()
          }
        }
      }
    }
  }
}
