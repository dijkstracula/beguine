package ivy;

import com.microsoft.z3.*;

import java.util.*;

import ivy.decls.Decls;
import ivy.sorts.IvySort;
import ivy.sorts.Sorts;
import ivy.sorts.Sorts.*;

/**
 * A port of ivy_gen and gen classes, which are autogenerated each time
 * by ivy_to_cpp.  Generates and checks a particular protocol's particular
 * (public) action.
 * @param <P> The protocol we are generating events for
 */
public abstract class ActionGenerator<P> {
    private final Context ctx;
    private final Solver slvr;

    protected final Sorts sorts;
    protected final Decls decls;

    private int tmp_ctr;

    // TODO: is there any point in passing in P here?
    public ActionGenerator(Random r, P p) {
        ctx = new Context();
        slvr = ctx.mkSolver();
        sorts = new Sorts(ctx, r);
        decls = new Decls(ctx, sorts, r);
    }

    protected void add(Expr<BoolSort> pred) {
        slvr.add(pred);
    }
    protected Model solve() {
        Status s = slvr.check();
        if (s != Status.SATISFIABLE) {
            throw new RuntimeException(String.format("Got %s back from the solver", s.toString()));
        }
        return slvr.getModel();
    }

    protected void push() { slvr.push(); }
    protected void pop() { slvr.pop(); }

    public Context getContext() { return ctx; }


    //abstract public int choose(int rng, String name);
    abstract public Model generate(P protocol);
    abstract public void execute(P protocol, Model m);

    String fresh_name() {
        return String.format("$tmp%d", tmp_ctr++);
    }

    protected IvyBool mkBool(String name) {
        return sorts.mkBool(name);
    }
    protected IvyInt mkInt(String name) {
        return sorts.mkInt(name);
    }
    protected IvyInt mkFiniteInt(String name, long min, long max) {
        return sorts.mkInt(name, min, max);
    }

    protected <J, Z extends Sort, I extends IvySort<J,Z>> Decls.IvyConst<J,Z,I> mkConst(String name, I sort) {
        return decls.mkConst(name, sort);
    }

    // TODO: this will eventually live in the SortFactory.
    /*
    protected void mk_bv(String name, int width) {
        if (width <= 0) {
            throw new RuntimeException("bv width must be positive");
        }
        add_sort(name, ctx.mkBitVecSort(width));
    }
    protected void mk_enum(String name, List<String> values) {
        add_sort(name, ctx.mkEnumSort(name, values.toArray(new String[0])));
    }
    protected void mk_int(String name) {
        add_sort(name, ctx.mkIntSort());
    }
    protected void mk_sort(String name) {
        add_sort(name, ctx.mkUninterpretedSort(name));
    }
    protected void mk_string(String name) {
        add_sort(name, ctx.mkStringSort());
    }

    protected void mk_const(String name, String sort) {
        mk_const(name, enum_sorts.get(sort));
    }
    protected void mk_const(String name, Sort sort) {
        mk_decl(name, List.of(), sort);
    }

    protected void mk_decl(String name, List<String> domain_sorts, String range_sort) {
        mk_decl(name,
                domain_sorts.stream().map(enum_sorts::get).collect(Collectors.toList()),
                enum_sorts.get(range_sort));
    }
    protected void mk_decl(String name, List<Sort> domain, Sort range) {
        FuncDecl<Sort> fn = ctx.mkFuncDecl(name, domain.toArray(new Sort[0]), range);
        decl_names.add(ctx.mkSymbol(name));
        add_decl(name, fn);
    }

    protected Expr<Sort> mk_apply_expr(String decl_name, List<Integer> args) {
        FuncDecl<? extends Sort> decl = decls.get(decl_name);
        if (decl.getArity() != args.size()) {
            throw new IvyExceptions.FuncArityMismatch(decl.getArity(), args.size());
        }
        Streams.zip(Arrays.stream(decl.getDomain()), args.stream(), (sort, arg) -> {
            switch (sort.getSortKind()) {
                case Z3_BOOL_SORT:
                    return ctx.mkBool(!arg.equals(0));
                case Z3_BV_SORT:
                    return ctx.mkBV(arg, ((BitVecSort)sort).getSize());
                case Z3_INT_SORT:
                    return ctx.mkInt(arg);
                default:
                    return null; // TODO
            }
        });
        return null; //TODO
    }

    protected void set_int_ranges(String sort_name, int min, int max) {
        Sort s = enum_sorts.get(sort_name);
        if (int_ranges.containsKey(s)) {
            throw new IvyExceptions.DuplicateSortRangeException(s);
        }
        int_ranges.put(s, new Pair<>(BigInteger.valueOf(min), BigInteger.valueOf(max)));
    }

    // TODO: we'll have to figure out dispatching on other rhs types.
    // TODO: we'll probably have lost that lhs is an IntSort :(
//    protected BoolExpr constrain(Context ctx, String lhs, int rhs) {
 //       return ctx.mkEq(decls.get(lhs), ctx.mkInt(rhs));
  //  }

    void add_smtlib(String blob) {
        BoolExpr constraints[] = ctx.parseSMTLIB2String(
                blob,
                sort_names.toArray(new Symbol[0]),
                enum_sorts.values().toArray(new Sort[0]),
                decl_names.toArray(new Symbol[0]),
                decls.values().toArray(new FuncDecl[0])
        );
        slvr.add(constraints);
    }


    protected Expr<?> apply(String decl_name, List<Expr<?>> args) {
        return apply(decls.get(decl_name), args);
    }
    protected Expr<?> apply(FuncDecl<?> decl, List<Expr<?>> args) {
        return decl.apply(args.toArray(new Expr<?>[0]));
    }


    private void add_decl(String name, FuncDecl<?> d) throws IvyExceptions.DuplicateDeclException {
        if (decls.put(name, d) != null) {
            throw new IvyExceptions.DuplicateDeclException(d);
        }
    }

    private void addSort(String name, IvySort s) throws IvyExceptions.DuplicateSortDefException {
        if (enum_sorts.put(name, s) != null) {
            throw new IvyExceptions.DuplicateSortDefException(s);
        }
    }
    */

}
